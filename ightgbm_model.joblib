import streamlit as st
import joblib
import pandas as pd
import numpy as np

st.title('Solar Power Generation Prediction')

# Define a function to load the model
@st.cache_resource
def load_model():
    """Loads the saved LightGBM model."""
    return joblib.load('lightgbm_model.joblib')

# Load the model
model = load_model()

st.header('Enter Environmental Variables:')

# Create input fields for the features
distance_to_solar_noon = st.number_input('Distance to Solar Noon', min_value=0.0, max_value=1.5, value=0.5, step=0.01)
temperature = st.number_input('Temperature (°F)', min_value=0, max_value=100, value=70)
wind_direction = st.number_input('Wind Direction (°)', min_value=0, max_value=360, value=25)
wind_speed = st.number_input('Wind Speed (mph)', min_value=0.0, max_value=50.0, value=8.0, step=0.1)
sky_cover = st.number_input('Sky Cover (0-4)', min_value=0, max_value=4, value=1)
visibility = st.number_input('Visibility (miles)', min_value=0.0, max_value=10.0, value=10.0, step=0.1)
humidity = st.number_input('Humidity (%)', min_value=0, max_value=100, value=70)
average_wind_speed_period = st.number_input('Average Wind Speed (Period)', min_value=0.0, max_value=50.0, value=7.5, step=0.1)
average_pressure_period = st.number_input('Average Pressure (Period)', min_value=28.0, max_value=32.0, value=29.9, step=0.01)

# Feature engineering based on the training data
temp_wind_interaction = temperature * wind_speed
humidity_sky_interaction = humidity * sky_cover
distance_to_solar_noon_sq = distance_to_solar_noon**2

if st.button('Predict Power Generation'):
    # Create a DataFrame from user inputs, ensuring column order matches training data
    input_data = pd.DataFrame({
        'distance-to-solar-noon': [distance_to_solar_noon],
        'temperature': [temperature],
        'wind-direction': [wind_direction],
        'wind-speed': [wind_speed],
        'sky-cover': [sky_cover],
        'visibility': [visibility],
        'humidity': [humidity],
        'average-wind-speed-(period)': [average_wind_speed_period],
        'average-pressure-(period)': [average_pressure_period],
        'temp_wind_interaction': [temp_wind_interaction],
        'humidity_sky_interaction': [humidity_sky_interaction],
        'distance-to-solar-noon_sq': [distance_to_solar_noon_sq]
    })

    # Ensure the column order is the same as the training data (using X_train from the notebook)
    # This assumes X_train is available in the environment where the script is run
    # In a real deployment, you would save and load the column order or ensure consistency
    # For this example, we'll assume the order created matches the training data for simplicity
    # A more robust solution would involve saving the column order during training

    prediction = model.predict(input_data)
    st.subheader('Predicted Power Generation')
    st.write(f'{prediction[0]:,.2f} kWh')
